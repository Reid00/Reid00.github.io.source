---
title: "Linux 服务器登录后的常见操作"
date: 2023-02-27T15:32:24+08:00
lastmod: 2023-02-27T15:32:24+08:00
author: ["Reid"]
categories: 
- Linux
- Server
tags: 
- Linux
- Server
keyword:
- Linux
- Server
description: ""
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: Linux-服务器登录后的常见操作
draft: false # 是否为草稿
comments: true
showToc: true # 显示目录
TocOpen: false # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
---

## Linux修改主机名修改hostname的方法
1. 临时修改Linux主机名的方法
`hostname newname`
执行命令后发现没有变化。重新开终端即可显示，你也可以通过uname -n命令来查看当前的主机名。

2. 永久修改Linux主机名的方法
- 使用 hostnamectl 来改变主机名称
```sh
[root@nebula3-01 ~]# hostnamectl
   Static hostname: nebula3-01
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 1d8987d66da0c7cd7960ca4e5aefe30f
           Boot ID: 717058195e934eb88f4631adf25ab163
    Virtualization: kvm
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-1160.el7.x86_64
      Architecture: x86-64

[root@nebula-test02 ~]# hostnamectl set-hostname nebula3-02
[root@nebula-test02 ~]# hostnamectl
   Static hostname: nebula3-02
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 1d8987d66da0c7cd7960ca4e5aefe30f
           Boot ID: 6b836dcf9c274ef48f334e6b53f8e296
    Virtualization: kvm
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-1160.el7.x86_64
      Architecture: x86-64
[root@nebula-test02 ~]# 
```
退出后，重新登录即可

- 通过修改`/etc/hostname` 文件，本质和上面一样
```sh
[root@nebula-test03 ~]# hostnamectl
   Static hostname: nebula-test03.novalocal
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 1d8987d66da0c7cd7960ca4e5aefe30f
           Boot ID: 683f9e34bce149659226bcdfc0dce6ed
    Virtualization: kvm
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-1160.el7.x86_64
      Architecture: x86-64
[root@nebula-test03 ~]# cat /etc/hostname
nebula-test03.novalocal
[root@nebula-test03 ~]# echo "nebula3-03" > /etc/hostname

[root@nebula-test03 ~]# hostnamectl
   Static hostname: nebula3-03
Transient hostname: nebula-test03.novalocal
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 1d8987d66da0c7cd7960ca4e5aefe30f
           Boot ID: 683f9e34bce149659226bcdfc0dce6ed
    Virtualization: kvm
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-1160.el7.x86_64
      Architecture: x86-64
```

## 通过机器名ping 通彼此
修改`/etc/hosts` 文件，添加 `ip 域名` 即可。
vim /etc/hosts
```sh
172.18.163.124 test-server-01
172.18.163.115 test-server-02
172.18.163.114 test-server-03
172.18.163.85  test-server-04
```

## 查看服务器是否为SSD
- 方法一
判断`cat /sys/block/*/queue/rotational` 的返回值（其中*为你的硬盘设备名称，例如sda等等），如果返回1则表示磁盘可旋转，那么就是HDD了；反之，如果返回0，则表示磁盘不可以旋转，那么就有可能是SSD了。

- 方法二
`lsblk -d -o name,rota` 命令
```sh
[root@nebula3-04 ~]# lsblk -d -o name,rota
NAME ROTA
vda     1
```

## 划分分区并挂载磁盘
本操作以该场景为例，当云服务器挂载了一块新的数据盘时，使用fdisk分区工具将该数据盘设为主分区，分区形式默认设置为MBR，文件系统设为ext4格式，挂载在“/mnt/sdc”下，并设置开机启动自动挂载。
1. fdisk -l 显示信息
```sh
[root@ecs-test-0001 ~]# fdisk -l
Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000bcb4e

   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *        2048    83886079    41942016   83  Linux

Disk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```
表示当前的云服务器有两块磁盘，“/dev/vda”是系统盘，“/dev/vdb”是新增数据盘。

2. 执行以下命令，进入fdisk分区工具，开始对新增数据盘执行分区操作。
**fdisk 新增数据盘**
以新挂载的数据盘“/dev/vdb”为例：
**fdisk /dev/vdb**
```sh
[root@ecs-test-0001 ~]# fdisk /dev/vdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0x38717fc1.

Command (m for help): 
```

3. 输入“n”，按“Enter”，开始新建分区。
```sh
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
```
表示磁盘有两种分区类型：
- “p”表示主分区。
- “e”表示扩展分区。
>磁盘使用MBR分区形式，最多可以创建4个主分区，或者3个主分区加1个扩展分区，扩展分区不可以直接使用，需要划分成若干个逻辑分区才可以使用。 磁盘使用GPT分区形式时，没有主分区、扩展分区以及逻辑分区之分。

4. 以创建一个主要分区为例，输入“p”，按“Enter”，开始创建一个主分区。
```sh
Select (default p): p
Partition number (1-4, default 1): 
```
“Partition number”表示主分区编号，可以选择1-4。

5. 以分区编号选择“1”为例，输入主分区编号“1”，按“Enter”。
```sh
Partition number (1-4, default 1): 1
First sector (2048-209715199, default 2048):
```
“First sector”表示起始磁柱值，可以选择2048-209715199，默认为2048。

6. 以选择默认起始磁柱值2048为例，按“Enter”
系统会自动提示分区可用空间的起始磁柱值和截止磁柱值，可以在该区间内自定义，或者使用默认值。起始磁柱值必须小于分区的截止磁柱值。
```sh
First sector (2048-209715199, default 2048):
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-209715199, default 209715199):
```
“Last sector”表示截止磁柱值，可以选择2048-209715199，默认为209715199。

7. 以选择默认截止磁柱值209715199为例，按“Enter”。
系统会自动提示分区可用空间的起始磁柱值和截止磁柱值，可以在该区间内自定义，或者使用默认值。起始磁柱值必须小于分区的截止磁柱值。
```sh
Last sector, +sectors or +size{K,M,G} (2048-209715199, default 209715199):
Using default value 209715199
Partition 1 of type Linux and of size 100 GiB is set

Command (m for help):
```
表示分区完成，即为数据盘新建了1个分区。

8. 输入“p”，按“Enter”，查看新建分区的详细信息。
```sh
Command (m for help): p

Disk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x38717fc1

   Device Boot      Start         End      Blocks   Id  System
/dev/vdb1            2048   209715199   104856576   83  Linux

Command (m for help):
```
表示新建分区“/dev/vdb1”的详细信息。

9. 输入“w”，按“Enter”，将分区结果写入分区表中。
```sh
Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
```
表示分区创建完成。
**如果之前分区操作有误，请输入“q”，则会退出fdisk分区工具，之前的分区结果将不会被保留。**

10. 执行`partprobe`命令，将新的分区表变更同步至操作系统。

11. 执行`mkfs -t ext4 /dev/vdb1`命令，将新建分区文件系统设为系统所需格式。

12. 执行`mkdir 挂载目录 => mkdir /mnt/sdc `命令，新建挂载目录。

13. 执行`mount /dev/vdb1 /mnt/sdc`命令，将新建分区挂载到12中创建的目录下

14. 查看挂载结果 `df -TH`
```sh
[root@ecs-test-0001 ~]# df -TH
Filesystem     Type      Size  Used Avail Use% Mounted on
/dev/vda1      ext4       43G  1.9G   39G   5% /
devtmpfs       devtmpfs  2.0G     0  2.0G   0% /dev
tmpfs          tmpfs     2.0G     0  2.0G   0% /dev/shm
tmpfs          tmpfs     2.0G  9.1M  2.0G   1% /run
tmpfs          tmpfs     2.0G     0  2.0G   0% /sys/fs/cgroup
tmpfs          tmpfs     398M     0  398M   0% /run/user/0
/dev/vdb1      ext4      106G   63M  101G   1% /mnt/sdc
```
表示新建分区“/dev/vdb1”已挂载至“/mnt/sdc”。
