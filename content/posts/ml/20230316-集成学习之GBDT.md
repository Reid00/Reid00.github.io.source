---
title: "集成学习之GBD"
date: 2023-03-16T19:35:27+08:00
lastmod: 2023-03-16T19:35:27+08:00
author: ["Reid"]
categories: 
- Machine Learning
- 机器学习
tags: 
- 集成学习
- GBDT
keyword:
- Machine Learning
- 机器学习
description: 集成学习之GBD
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: 集成学习之GBDT
draft: false # 是否为草稿
comments: true
showToc: true # 显示目录
TocOpen: false # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
---

#### 什么是GBDT

到底什么是梯度提升树？所谓的GBDT实际上就是：

> GBDT = Gradient Descent + Boosting + Desicion Tree

与Adaboost算法类似，GBDT也是使用了前向分布算法的加法模型。只不过弱学习器限定了**只能使用CART回归树模型，同时迭代思路和Adaboost也有所不同。**

**在Adaboost算法中，我们是利用前一轮迭代弱学习器的误差率来更新训练集的权重。而Gradient Boosting是通过算梯度（gradient）来定位模型的不足。**

https://mp.weixin.qq.com/s/rmStKvdHq-BOCJo8ZuvgfQ



>最常用的决策树算法: RF, Adaboost, GBDT
>
>https://mp.weixin.qq.com/s/tUl3zhVxLfUd7o06_1Zg2g

#### Xgboost 的优势和原理

>原理: https://www.jianshu.com/p/920592e8bcd2 
>
>​		  https://www.jianshu.com/p/ac1c12f3fba1
>
>优势: https://snaildove.github.io/2018/10/02/get-started-XGBoost/

#### LightGBM 详解

>https://blog.csdn.net/VariableX/article/details/106242202

![](..\img\2020-04-15-集成学习GBDT.png)





#### GBDT分类算法流程

GBDT的分类算法从思想上和GBDT的回归算法没有区别，但是**由于样本输出不是连续的值，而是离散的类别**，导致我们**无法直接从输出类别去拟合类别输出的误差**。

为了解决这个问题，主要有两个方法：

1. 用指数损失函数，此时GBDT退化为Adaboost算法。
2. 用类似于逻辑回归的对数似然损失函数的方法。也就是说，我们用的是类别的预测概率值和真实概率值的差来拟合损失。

下面我们用对数似然损失函数的GBDT分类。而对于对数似然损失函数，又有二元分类和多元分类的区别。





#### sklearn中的GBDT调参大法

https://mp.weixin.qq.com/s/756Xsy0uhnb8_rheySqLLg

##### Boosting重要参数

分类和回归算法的参数大致相同，不同之处会指出。

- `n_estimators`: 弱学习器的个数。个数太小容易欠拟合，个数太大容易过拟合。默认是100，在实际调参的过程中，常常将`n_estimators`和参数`learning_rate`一起考虑。

- `learning_rate`: 每个弱学习器的权重缩减系数，也称作步长。如果我们在强学习器的迭代公式加上了正则化项：，则通过`learning_rate`来控制其权重。对于同样的训练集拟合效果，较小的`learning_rate`意味着需要更多的弱学习器。通常用二者一起决定算法的拟合效果。所以两个参数`n_estimators`和`learning_rate`要一起调参。一般来说，可以从一个小一点的补偿开始调参，默认是1。

- `subsample`: 不放回抽样的子采样，取值为(0,1]。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间，默认是1.0，即不使用子采样。

- `init`: 初始化时的弱学习器，即。如果我们对数据有先验知识，或者之前做过一些拟合，可以用init参数提供的学习器做初始化分类回归预测。一般情况下不输入，直接用训练集样本来做样本集的初始化分类回归预测。

- `loss`: GBDT算法中的损失函数。**分类模型和回归模型的损失函数是不一样**。

- - 对于回归模型，可以使用均方误差ls，绝对损失lad，Huber损失huber和分位数损失quantile，默认使用均方误差ls。如果数据的噪音点不多，用默认的均方差ls比较好；如果噪音点较多，则推荐用抗噪音的损失函数huber；而如果需要对训练集进行分段预测，则采用quantile。
  - 对于分类模型，可以使用对数似然损失函数deviance和指数损失函数exponential。默认是对数似然损失函数deviance。在原理篇中对这些分类损失函数有详细的介绍。一般来说，推荐使用默认的"deviance"。它对二元分离和多元分类各自都有比较好的优化。而指数损失函数等于把我们带到了Adaboost算法。

- `alpha`: 这个参数**只有回归算法有**，当使用Huber损失huber和分位数损失quantile时，需要指定分位数的值。默认是0.9，如果噪音点较多，可以适当降低这个分位数的值。

##### 弱学习器参数

GBDT使用了CART回归决策树，因此它的参数基本和决策树类似。

- `max_features`: 划分时考虑的最大特征数，默认是"None"。默认时表示划分时考虑所有的特征数；如果是"log2"意味着划分时最多考虑个log2N特征；如果是"sqrt"或者"auto"意味着划分时最多考虑根号N个特征。如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑（百分比*N）取整后的特征数。其中N为样本总特征数。一般来说，如果样本特征数不多，比如小于50，我们用默认的"None"就可以了，如果特征数非常多，可以灵活控制划分时考虑的最大特征数，以控制决策树的生成时间。
- `max_depth`: 决策树最大深度。如果不输入，默认值是3。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。
- `min_samples_split`: 内部节点再划分所需最小样本数。限制子树继续划分的条件，如果某节点的样本数少于`min_samples_split`，则不会继续再尝试选择最优特征来进行划分。默认是2，如果样本量数量级非常大，则增大这个值。
- `min_samples_leaf`: 叶子节点最少样本数。限制叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。
- `min_weight_fraction_leaf`: 叶子节点最小的样本权重和这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。
- `max_leaf_nodes`: 最大叶子节点数。通过限制最大叶子节点数，可以防止过拟合，默认是None，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。
- `min_impurity_split`: 节点划分最小不纯度。这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。一般不推荐改动默认值1e-7。

GBDT有很多优点：

- 可以灵活处理连续值和离散值等各种类型的数据
- 可以少做一点特征工程部分
- 能够处理字段缺失的数据
- 能够自动组合多个特征，不用关心特征间是否依赖
- 能够自动处理特征间的交互，处理多种类型的异构数据
- 可以通过选择损失函数，来增强对异常值的鲁棒性，如：Huber损失函数和Quantile损失函数

GBDT也有一些局限性：

- 在高维稀疏数据集上，表现不如神经网络和SVM
- Boosting家族算法，基学习器需要串行训练，只能通过局部并行提高速度（自采样的SGBT）